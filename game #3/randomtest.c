#include <time.h>
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
	// random.c를 작성하다가 의문점이 생겨 만든 소스 파일

	// rand : 예측할 수 없는 하나의 난수를 생성한다.
	// 난수의 범위는 0~RAND_MAX 까지이며 RAND_MAX는 0x7fff이므로,
	// 결국 난수의 범위는 0~32767 이다.
	// https://shaeod.tistory.com/292

	// 의문점 : 난수의 범위에 해당하는 정수(32768개)가
	// 3으로 나누어 떨어지지 않으므로
	// 3으로 나누었을 때 나머지가 0, 1, 2인 경우의 수가 모두 같지 않다.
	// (0과 1은 10923, 2는 10922)
	// 따라서 아래 주석 코드와 같이 1 ~ 3 사이의 난수를 생성하면
	// 나머지가 2, 즉 3일 확률이 다른 것보다 조금 낮지 않을까?

	// int one = 0; 
	// int two = 0; 
	// int three = 0;
	// srand(time(NULL)); // 난수 초기화
	// for (int i = 0; i < 100000000; i++)
	// {
	// 	int num = rand() % 3 + 1; // 1 ~ 3
	// 	if (num == 1)
	// 	{
	// 		one++;
	// 	}
	// 	else if (num == 2)
	// 	{
	// 		two++;
	// 	}
	// 	else if (num == 3)
	// 	{
	// 		three++;
	// 	}
	// 	if (i == 99999999)
	// 	{
	// 		printf("one: %d, two: %d, three: %d", one, two, three);
	// 	}
	// }
	// 테스트 결과 : 3이 적게 나오는 편인 것 같긴 하지만 이는 적절한 테스트 방식이 아니라는 판단을 내렸다.
	// 따라서 이번에는 아래 코드로 난수의 범위가 0~32767이 맞는 지를 테스트해보기로 했다.

	int a, b, c, d, e, f, g, h = 0;
	srand(time(NULL)); // 난수 초기화
	for (int i = 0; i <= 100000000; i++)
	{
		int num = rand();
		if (0 <= num && num < 5000)
			a++;
		else if (5000 <= num && num < 10000)
			b++;
		else if (10000 <= num && num < 15000)
			c++;
		else if (15000 <= num && num < 20000)
			d++;
		else if (20000 <= num && num < 25000)
			e++;
		else if (25000 <= num && num < 30000)
			f++;
		else if (30000 <= num && num <= 32767)
			g++;
		else // 범위 테스트
			h++;
	}
	printf("%d %d %d %d %d %d %d %d %d", a, b, c-1, d-4198400, e-1, f, g, h, a+b+c+d+e+f+g+h-4198402);
	// 테스트 결과 : 괜찮은 성과가 있었다. 일단 범위는 h의 값이 항상 0으로 나오는 것으로 보아 아마도 0~32767이 맞는 것 같다.
	// rand()로 숫자 몇 개를 뽑아내보니 첫 번째 숫자가 시간의 경과에 따라 일정한 값이 증가하는 듯한 패턴을 보여서
	// 5000 단위로 구간을 나눠 많은 숫자를 뽑아보았더니
	// 다른 구간은 전부 일정한데 유독 15000 이상, 20000 미만 구간에서 난수가 다른 구간보다 어림잡아 1.3배 가량 많이 생성되었다.
	// 코드를 수정하며 확인해보니 반복문을 한 번만 실행시켜도 c 범위에 1, d 범위에 4198400, e 범위에 1이라는 값이 변하지 않고 카운팅 되어 있었다.
	// 4198401은 2진법으로 특이한 숫자 같지만 무슨 의미인지까지는 알 수가 없어 일단 변하지 않는 값을 빼주고 반복문을 작성했더니
	// 범위가 같은 모든 구간에서 거의 비슷하게 난수가 생성되었다.
	// 이처럼 특이한 점들을 발견하긴 했지만 일단은 아쉽게도 처음의 궁금증을 완벽히 해결하지 못했다.
	// 의문점에서 적은 것처럼 나머지가 2일 확률이 0, 1보다 낮지 않을까라는 생각에는 변함이 없다.

	// rand 함수 원형을 찾아보다가 이것 저것 알게 되었다.
	// C 언어의 표준 라이브러리 함수 헤더 파일이 보통은 컴파일러가 설치된 디렉터리 아래 찾아가면 include 디렉터리 아래에 있다고 해서(http://blog.naver.com/ahalinux/221454390932)
	// stdlib.h 파일과 관련된 파일, rand가 포함된 파일을 찾아보니 읽기가 너무 어려워서 함수 설명 글 위주로 살펴보았다.
	// 위키백과에서는 함수 int rand (void);가 0부터 RAND_MAX 사이의 의사 난수를 반환하는 의사 난수 생성 함수라고 적혀있었다.
	// 여기서 RAND_MAX는 OS, 컴파일러 등에 따라 달라지는 것으로 보인다.
	// 내 컴퓨터의 경우 vscode를 통해 `C:/mingw64/x86_64-w64-mingw32/include/stdlib.h`의 106번째 줄에서
	// `#define RAND_MAX 0x7fff`, 10진수로 RAND_MAX의 값이 32767임을 확인할 수 있었다.
	// 그리고 의사 난수란 나무위키에 따르면 난수는 아니나 난수로 취급이 가능한 수열을 지칭한다고 한다.
	// 보통 난수를 만들 수 없는 컴퓨터 등에서 난수를 사용하기 위해서 만들어진 수열로,
	// 충분한 숫자를 가지고 적당한 분포를 가진 수열 또는 수열을 생성 가능한 식을 통해 만들어지면 의사 난수로 사용 가능하다고 한다.
	// 컴퓨터에서는 특수한 하드웨어 없이 완전한 난수를 생성할 방법이 없기 때문에 보통 의사 난수를 사용한다고 하니,
	// 아마 rand()가 그런 경우가 아닌가 싶다.
	// https://modoocode.com/121 에서도 stdlib.h 함수 설명에서 의사 난수를 실제 난순열이 아닌 특정한 알고리즘에 따라 난수처럼 나타나는 수열로 설명하고 있다.
	// 이 의사 난수라는 것이 생각보다 어렵고 복잡해서 당황했다. 그냥 쉽게 생성할 수 있는 것이라고 생각했는데...
	// 네이버 지식백과(https://terms.naver.com/entry.nhn?cid=58944&docId=3580433&categoryId=5897)에서도 의사 난수를 다뤘는데,
	// 예측할 수 없는 완전한 난수를 생성한다는 것이 생각보다 정말 정말 어려운 일인 것 같다.
	// 아마 내가 앞서 rand()가 반환한 난수에서 특정한 규칙을 발견했다고 느낀 것도 rand()가 의사 난수를 생성하기 때문에 눈대중으로도 어느 정도 예측 가능해서가 아닌가 싶다.
	// 너무 깊게 들어가기에는 아직 때가 아닌 것 같아 일단 이 정도로 rand()에 대한 공부를 마무리하려고 한다.
	// 수학의 중요성에 대해서는 확실하게 깨닫고 간다.

	return 0;
}